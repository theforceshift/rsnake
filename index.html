<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js Sketch</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Syne+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.3/p5.min.js"></script>
</head>
<body>
    <script>

// Define a constant for controlling the overall movement speed for both player and snake
const MOVEMENT_SPEED_FACTOR = 10; // This factor determines the "tick" rate.
                                 // Both player and snake move one segment per MOVEMENT_SPEED_FACTOR frames.
                                 // Lower values = faster, higher values = slower.

let playerX, playerY;
// playerSpeed is removed, movement is now quantized by segmentSize
let segmentSize = 20; // Size of each snake segment and player

// Variables to store the player's last intended movement direction for dashing
let playerCurrentDirX = 0;
let playerCurrentDirY = 0;
let DASH_DISTANCE_SQUARES = 4; // How many squares the dash covers

// Variables for the dashing animation trail
let dashTrail = [];
const DASH_ECHO_LIFETIME = 25; // How many frames an echo lasts (approx 0.4 seconds at 60fps)
const DASH_ECHO_COUNT = 8;    // How many echoes to generate along the dash path

// New variables for dash counter and snake speed boost
let dashesUsed = 0;
const DASH_SPEED_BOOST_THRESHOLD = 3; // Number of dashes before snake gets faster
const SNAKE_SPEED_BOOST_MULTIPLIER = 1.5; // How much faster the snake gets (e.g., 1.5 for 1.5x speed)

// NEW CONSTANT: Adjusts the snake's base speed relative to the player's speed.
// 1.0 = same speed as player
// > 1.0 = faster than player
// < 1.0 = slower than player
const SNAKE_BASE_SPEED_MULTIPLIER = 2; 

let currentFramesPerSegment; // The actual frames per segment the snake currently uses
let snakeBaseFramesPerSegment; // Stored initial value
let snakeBoostedFramesPerSegment; // Stored boosted value

let snakeSegments = [];
let snakeLength;
let initialSnakeLength = 40; // Starting length of the snake
let minSnakeLength = 5; // Target length to win the game

let snakeDirX = 1; // Initial snake movement direction (right)
let snakeDirY = 0;
// snakeShortenInterval is independent of speed
let snakeShortenInterval = 120; // Frames before snake shortens by one segment (2 seconds at 60fps)
let lastShortenTime = 0;

let gameMode = 'startScreen'; // 'startScreen', 'playing', 'win', 'lose'
let gameResultReason = ""; // Stores "bait_caught", "snake_wall_crash", "snake_self_collision", "snake_too_short"

function setup() {
  createCanvas(windowWidth, windowHeight); // Fixed bug: ensuring canvas uses windowHeight
  textFont('Syne Mono'); // Set font to Syne Mono for all text (requires external loading)

  // Pre-calculate snake speed values based on new SNAKE_BASE_SPEED_MULTIPLIER
  snakeBaseFramesPerSegment = floor(MOVEMENT_SPEED_FACTOR / SNAKE_BASE_SPEED_MULTIPLIER);
  // Use floor to ensure integer for frameCount % operation, applied on top of base speed
  snakeBoostedFramesPerSegment = floor(snakeBaseFramesPerSegment / SNAKE_SPEED_BOOST_MULTIPLIER);

  // No resetGame() here, as we start in 'startScreen' mode
}

function resetGame() {
  // Quantize player start position to nearest segmentSize multiple
  playerX = floor(width / 2 / segmentSize) * segmentSize;
  playerY = floor(height / 2 / segmentSize) * segmentSize;

  snakeSegments = [];
  // Initialize snake far from the player, also quantized
  let startX = floor(width / 4 / segmentSize) * segmentSize;
  let startY = floor(height / 4 / segmentSize) * segmentSize;
  for (let i = 0; i < initialSnakeLength; i++) {
    snakeSegments.push({ x: startX - i * segmentSize, y: startY });
  }

  snakeLength = initialSnakeLength;
  snakeDirX = 1;
  snakeDirY = 0;
  lastShortenTime = frameCount;
  gameMode = 'playing'; // Set to playing mode after reset
  gameResultReason = ""; // Reset reason for game over
  frameRate(60); // Ensure consistent speed

  // Initialize player's current direction
  playerCurrentDirX = 1; // Default to moving right
  playerCurrentDirY = 0;

  dashTrail = []; // Clear any old dash trails

  // Reset dash counter and snake speed
  dashesUsed = 0;
  currentFramesPerSegment = snakeBaseFramesPerSegment; // Snake starts at normal speed
}

function draw() {
  background(0); // Black background

  // Draw the dash trail first, so it appears behind the player
  drawDashTrail();

  if (gameMode === 'startScreen') {
    displayStartScreen();
  } else if (gameMode === 'playing') {
    movePlayer();
    updateSnake();
    checkCollisions(); // Checks for all collision-based win/lose conditions
    checkWinByLength(); // Checks for win condition based on snake length
    drawPlayer();
    drawSnake();
  } else if (gameMode === 'win') {
    // Consolidated win messages under "YOU SURVIVED!"
    if (gameResultReason === "snake_self_collision") {
      displayMessage("YOU SURVIVED!", "The snake tied itself in a knot!");
    } else if (gameResultReason === "snake_too_short") {
      displayMessage("YOU SURVIVED!", "The snake is too short to chase you anymore!");
    } else if (gameResultReason === "snake_wall_crash") { // NEW: Snake crashing is a win
      displayMessage("YOU SURVIVED!", "The snake crashed into the wall!");
    } else {
      displayMessage("YOU SURVIVED!", "Congratulations!"); // Fallback
    }
  } else if (gameMode === 'lose') {
    // Dedicated lose message for being caught
    if (gameResultReason === "bait_caught") {
      displayMessage("YOU WERE CAUGHT!", "The snake caught you!");
    } else {
      displayMessage("GAME OVER", "An unexpected error occurred!"); // Fallback for any other unexpected lose
    }
  }
}

function movePlayer() {
  // Only allow player movement on specific ticks, synchronized with the snake
  if (frameCount % MOVEMENT_SPEED_FACTOR === 0) {
    let movedHorizontallyThisTick = false;

    // Prioritize horizontal movement for updating position and direction
    if (keyIsDown(LEFT_ARROW) || keyIsDown(65)) { // 'A' key
      playerX -= segmentSize; // Quantized movement
      playerCurrentDirX = -1;
      playerCurrentDirY = 0;
      movedHorizontallyThisTick = true;
    } else if (keyIsDown(RIGHT_ARROW) || keyIsDown(68)) { // 'D' key
      playerX += segmentSize; // Quantized movement
      playerCurrentDirX = 1;
      playerCurrentDirY = 0;
      movedHorizontallyThisTick = true;
    }

    // Only allow vertical movement and update direction if no horizontal movement was detected
    if (!movedHorizontallyThisTick) { // Check if horizontal movement happened this tick
      if (keyIsDown(UP_ARROW) || keyIsDown(87)) { // 'W' key
        playerY -= segmentSize; // Quantized movement
        playerCurrentDirX = 0;
        playerCurrentDirY = -1;
      } else if (keyIsDown(DOWN_ARROW) || keyIsDown(83)) { // 'S' key
        playerY += segmentSize; // Quantized movement
        playerCurrentDirX = 0;
        playerCurrentDirY = 1;
      }
    }
  }

  // Constrain player to canvas boundaries (position will always be a multiple of segmentSize)
  playerX = constrain(playerX, 0, width - segmentSize);
  playerY = constrain(playerY, 0, height - segmentSize);
}


function updateSnake() {
  // The snake moves a full segmentSize every currentFramesPerSegment frames
  if (frameCount % currentFramesPerSegment === 0) {
    let head = snakeSegments[0];

    // Calculate displacement to player
    let dx = playerX - head.x;
    let dy = playerY - head.y;

    let newDirX = snakeDirX;
    let newDirY = snakeDirY;

    // Snake AI: Prioritize the axis with the greater displacement to turn
    // Also, prevent immediate 180-degree turns
    if (abs(dx) > abs(dy)) { // More horizontal distance
      if (dx > 0 && snakeDirX !== -1) { // Player is to the right
        newDirX = 1;
        newDirY = 0;
      } else if (dx < 0 && snakeDirX !== 1) { // Player is to the left
        newDirX = -1;
        newDirY = 0;
      }
    } else { // More vertical distance
      if (dy > 0 && snakeDirY !== -1) { // Player is below
        newDirX = 0;
        newDirY = 1;
      } else if (dy < 0 && snakeDirY !== 1) { // Player is above
        newDirX = 0;
        newDirY = -1;
      }
    }

    // Update snake's current direction
    snakeDirX = newDirX;
    snakeDirY = newDirY;

    // Calculate new head position
    let newHeadX = head.x + snakeDirX * segmentSize;
    let newHeadY = head.y + snakeDirY * segmentSize;

    // Add new head to the beginning of the segments array
    snakeSegments.unshift({ x: newHeadX, y: newHeadY });

    // Remove tail segment if snake is too long
    if (snakeSegments.length > snakeLength) {
      snakeSegments.pop();
    }
  }

  // Shorten the snake over time
  if (frameCount - lastShortenTime > snakeShortenInterval) {
    if (snakeLength > minSnakeLength) { // Only shorten if not at minimum
      snakeLength--;
    }
    lastShortenTime = frameCount;
  }
}

// Axis-Aligned Bounding Box (AABB) collision detection
function checkAABBCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
  return (x1 < x2 + w2 &&
          x1 + w1 > x2 &&
          y1 < y2 + h2 &&
          y1 + h1 > y2);
}

function checkCollisions() {
  // If game is already over, no need to check for further collisions
  if (gameMode !== 'playing') return;

  let head = snakeSegments[0];
  let headRect = { x: head.x, y: head.y, w: segmentSize, h: segmentSize };
  let playerRect = { x: playerX, y: playerY, w: segmentSize, h: segmentSize };

  // 1. Player with Snake (Bait Caught) - LOSE
  // Check if player collides with any part of the snake, including the head
  for (let i = 0; i < snakeSegments.length; i++) {
    let segmentRect = { x: snakeSegments[i].x, y: snakeSegments[i].y, w: segmentSize, h: segmentSize };
    if (checkAABBCollision(playerRect.x, playerRect.y, playerRect.w, playerRect.h,
                           segmentRect.x, segmentRect.y, segmentRect.w, segmentRect.h)) {
      gameMode = 'lose';
      gameResultReason = "bait_caught";
      return; // Collision detected, stop checking
    }
  }

  // 2. Snake with Walls - WIN (You survived by making it crash!)
  if (head.x < 0 || head.x >= width || head.y < 0 || head.y >= height) {
    gameMode = 'win'; // <-- CHANGED TO WIN!
    gameResultReason = "snake_wall_crash";
    return; // Collision detected, stop checking
  }

  // 3. Snake with Self - WIN (You survived by making it crash!)
  // Starting from index 3 to prevent immediate collision with neck/shoulder segments during turns
  for (let i = 3; i < snakeSegments.length; i++) {
    let segmentRect = { x: snakeSegments[i].x, y: snakeSegments[i].y, w: segmentSize, h: segmentSize };
    if (checkAABBCollision(headRect.x, headRect.y, headRect.w, headRect.h,
                           segmentRect.x, segmentRect.y, segmentRect.w, segmentRect.h)) {
      gameMode = 'win';
      gameResultReason = "snake_self_collision";
      return; // Collision detected, stop checking
    }
  }
}

function checkWinByLength() {
  // Only check if game is still playing
  if (gameMode !== 'playing') return;

  if (snakeLength <= minSnakeLength) {
    gameMode = 'win';
    gameResultReason = "snake_too_short";
  }
}

function drawPlayer() {
  fill('#FF007F'); // Neon Pink for the player
  noStroke();
  rect(playerX, playerY, segmentSize, segmentSize);
}

function drawSnake() {
  let snakeColor;
  // Check if snake speed is boosted (currentFramesPerSegment is less than base speed)
  if (currentFramesPerSegment < snakeBaseFramesPerSegment) {
    // Blinking effect: alternate between neon green and yellow every 5 frames
    if (frameCount % 10 < 5) { // 10 frames total cycle (5 green, 5 yellow)
      snakeColor = '#39FF14'; // Neon Green
    } else {
      snakeColor = '#FFFF00'; // Yellow
    }
  } else {
    snakeColor = '#39FF14'; // Normal Neon Green
  }

  fill(snakeColor);
  noStroke();
  for (let i = 0; i < snakeSegments.length; i++) {
    rect(snakeSegments[i].x, snakeSegments[i].y, segmentSize, segmentSize);
  }
}

function displayMessage(title, subtitle) {
  fill(255); // White color for UI text
  textAlign(CENTER, CENTER);
  textSize(64);
  text(title, width / 2, height / 2 - 40);
  textSize(32);
  text(subtitle, width / 2, height / 2 + 20);
  textSize(24);
  text("Press 'R' to Restart", width / 2, height / 2 + 80);
}

// This function displays the start screen with the text title and instructions
function displayStartScreen() {
  textAlign(CENTER, CENTER);

  fill('#FF007F'); // Set fill color to Neon Pink for the title
  textSize(240);
  text("𓆈", width / 2, height / 2 - 120);

  fill(255); // Set fill color back to White for the instructions
  textSize(32);
  text("Arrow Keys or WASD to Move", width / 2, height / 2 - 20);
  text("Spacebar to Dash", width / 2, height / 2 + 30);
  text("Outrun the snake or make it crash!", width / 2, height / 2 + 80);

  textSize(32);
  text("Press ANY KEY to start", width / 2, height / 2 + 130);
}


// Function to handle the dash action and generate the trail
function dash() {
  if (gameMode !== 'playing') return; // Only allow dashing during gameplay

  // Increment dash counter
  dashesUsed++;

  // Check if snake speed needs to be boosted
  if (dashesUsed > DASH_SPEED_BOOST_THRESHOLD) {
    currentFramesPerSegment = snakeBoostedFramesPerSegment;
  }

  let currentX = playerX;
  let currentY = playerY;

  // Calculate target position
  playerX += playerCurrentDirX * DASH_DISTANCE_SQUARES * segmentSize;
  playerY += playerCurrentDirY * DASH_DISTANCE_SQUARES * segmentSize;

  // Constrain target position to canvas boundaries *before* generating trail
  playerX = constrain(playerX, 0, width - segmentSize);
  playerY = constrain(playerY, 0, height - segmentSize);

  // Generate dash trail points
  for (let i = 0; i < DASH_ECHO_COUNT; i++) {
    let t = i / (DASH_ECHO_COUNT - 1); // Interpolation factor from 0 to 1
    let echoX = lerp(currentX, playerX, t);
    let echoY = lerp(currentY, playerY, t);
    dashTrail.push({ x: echoX, y: echoY, frame: frameCount });
  }
}

// New function to draw the fading dash trail
function drawDashTrail() {
  for (let i = dashTrail.length - 1; i >= 0; i--) { // Iterate backwards for removal
    let echo = dashTrail[i];
    let age = frameCount - echo.frame;

    if (age > DASH_ECHO_LIFETIME) {
      dashTrail.splice(i, 1); // Remove old echo
    } else {
      let alpha = map(age, 0, DASH_ECHO_LIFETIME, 255, 0); // Fade out
      fill(255, 0, 127, alpha); // Neon Pink with calculated alpha
      noStroke();
      rect(echo.x, echo.y, segmentSize, segmentSize);
    }
  }
}


function keyPressed() {
  if (gameMode === 'startScreen') {
    // Any key press starts the game
    resetGame();
    return; // Don't process other key presses
  }

  if ((key === 'r' || key === 'R') && (gameMode === 'win' || gameMode === 'lose')) {
    resetGame();
  } else if (key === ' ') { // Spacebar for dash
    dash();
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (gameMode === 'playing') {
    // Re-center player and snake if playing and window resizes, ensuring quantization
    playerX = floor(constrain(playerX, 0, width - segmentSize) / segmentSize) * segmentSize;
    playerY = floor(constrain(playerY, 0, height - segmentSize) / segmentSize) * segmentSize;
    // For snake, just constrain its segments, don't reset
    for(let i=0; i < snakeSegments.length; i++){
        snakeSegments[i].x = floor(constrain(snakeSegments[i].x, 0, width - segmentSize) / segmentSize) * segmentSize;
        snakeSegments[i].y = floor(constrain(snakeSegments[i].y, 0, height - segmentSize) / segmentSize) * segmentSize;
    }
  } else {
    // If not playing, reset completely for a cleaner restart
    // This will take it back to the start screen, which then calls resetGame()
    // and re-quantizes everything
    gameMode = 'startScreen';
  }
}

    </script>
</body>
</html>
